# ç¬¬9ç« ï¼šé¡¹ç›®æ€»ç»“ä¸æ‰©å±•

## ğŸ¯ æœ¬ç« ç›®æ ‡

åœ¨è¿™æœ€åä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†ï¼š
- å›é¡¾æ•´ä¸ªé¡¹ç›®çš„æ¶æ„å’Œå®ç°
- æ€»ç»“ NestJS å¼€å‘çš„æœ€ä½³å®è·µ
- æä¾›é¡¹ç›®æ‰©å±•å»ºè®®
- åˆ†äº«å­¦ä¹ è·¯å¾„å’Œè¿›é˜¶æ–¹å‘
- è®¨è®ºå¸¸è§é—®é¢˜å’Œè§£å†³æ–¹æ¡ˆ

## ğŸ“‹ é¡¹ç›®å›é¡¾

### 1. é¡¹ç›®æ¶æ„æ€»è§ˆ

æˆ‘ä»¬æ„å»ºäº†ä¸€ä¸ªå®Œæ•´çš„ä¼ä¸šçº§åšå®¢ç³»ç»Ÿï¼ŒåŒ…å«ä»¥ä¸‹æ ¸å¿ƒåŠŸèƒ½ï¼š

```
ğŸ“¦ NestJS åšå®¢ç³»ç»Ÿ
â”œâ”€â”€ ğŸ” ç”¨æˆ·è®¤è¯ä¸æˆæƒ
â”‚   â”œâ”€â”€ JWT åŒä»¤ç‰Œæœºåˆ¶
â”‚   â”œâ”€â”€ è§’è‰²æƒé™æ§åˆ¶ (RBAC)
â”‚   â””â”€â”€ å¯†ç å®‰å…¨ç­–ç•¥
â”œâ”€â”€ ğŸ“ å†…å®¹ç®¡ç†
â”‚   â”œâ”€â”€ æ–‡ç«  CRUD æ“ä½œ
â”‚   â”œâ”€â”€ åˆ†ç±»å’Œæ ‡ç­¾ç³»ç»Ÿ
â”‚   â””â”€â”€ è¯„è®ºç³»ç»Ÿ
â”œâ”€â”€ ğŸ“ æ–‡ä»¶ç®¡ç†
â”‚   â”œâ”€â”€ å›¾ç‰‡ä¸Šä¼ å’Œå¤„ç†
â”‚   â”œâ”€â”€ æ–‡ä»¶éªŒè¯å’Œå®‰å…¨
â”‚   â””â”€â”€ é™æ€èµ„æºæœåŠ¡
â”œâ”€â”€ ğŸ”§ ç³»ç»ŸåŠŸèƒ½
â”‚   â”œâ”€â”€ é‚®ä»¶é€šçŸ¥ç³»ç»Ÿ
â”‚   â”œâ”€â”€ ç¼“å­˜ç­–ç•¥
â”‚   â””â”€â”€ æœç´¢åŠŸèƒ½
â”œâ”€â”€ ğŸ§ª æµ‹è¯•ä½“ç³»
â”‚   â”œâ”€â”€ å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ ç«¯åˆ°ç«¯æµ‹è¯•
â””â”€â”€ ğŸš€ éƒ¨ç½²è¿ç»´
    â”œâ”€â”€ Docker å®¹å™¨åŒ–
    â”œâ”€â”€ CI/CD æµæ°´çº¿
    â””â”€â”€ ç›‘æ§å’Œæ—¥å¿—
```

### 2. æŠ€æœ¯æ ˆæ€»ç»“

| åˆ†ç±» | æŠ€æœ¯é€‰å‹ | ä½œç”¨ |
|------|----------|------|
| **åç«¯æ¡†æ¶** | NestJS | ä¼ä¸šçº§ Node.js æ¡†æ¶ |
| **æ•°æ®åº“** | MySQL + Prisma | å…³ç³»å‹æ•°æ®åº“ + ORM |
| **ç¼“å­˜** | Redis | é«˜æ€§èƒ½ç¼“å­˜ |
| **è®¤è¯** | JWT + Passport | èº«ä»½è®¤è¯å’Œæˆæƒ |
| **æ–‡ä»¶å¤„ç†** | Multer + Sharp | æ–‡ä»¶ä¸Šä¼ å’Œå›¾ç‰‡å¤„ç† |
| **é‚®ä»¶æœåŠ¡** | Nodemailer | é‚®ä»¶å‘é€ |
| **æµ‹è¯•** | Jest + Supertest | å•å…ƒå’Œé›†æˆæµ‹è¯• |
| **æ–‡æ¡£** | Swagger/OpenAPI | API æ–‡æ¡£ç”Ÿæˆ |
| **å®¹å™¨åŒ–** | Docker + Docker Compose | åº”ç”¨å®¹å™¨åŒ– |
| **åå‘ä»£ç†** | Nginx | è´Ÿè½½å‡è¡¡å’Œé™æ€æ–‡ä»¶æœåŠ¡ |
| **ç›‘æ§** | Prometheus + Grafana | åº”ç”¨ç›‘æ§ |
| **æ—¥å¿—** | Winston | ç»“æ„åŒ–æ—¥å¿— |
| **é”™è¯¯è¿½è¸ª** | Sentry | é”™è¯¯ç›‘æ§å’Œè¿½è¸ª |

### 3. æ ¸å¿ƒè®¾è®¡æ¨¡å¼

#### æ¨¡å—åŒ–æ¶æ„
```typescript
// æ¸…æ™°çš„æ¨¡å—åˆ’åˆ†
@Module({
  imports: [
    UsersModule,
    AuthModule,
    ArticlesModule,
    CategoriesModule,
    TagsModule,
    CommentsModule,
    FilesModule,
    NotificationsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
```

#### ä¾èµ–æ³¨å…¥
```typescript
// æ¾è€¦åˆçš„æœåŠ¡è®¾è®¡
@Injectable()
export class ArticlesService {
  constructor(
    private prisma: PrismaService,
    private cacheService: RedisCacheService,
    private notificationService: NotificationService,
  ) {}
}
```

#### è£…é¥°å™¨æ¨¡å¼
```typescript
// å£°æ˜å¼çš„åŠŸèƒ½å¢å¼º
@Controller('articles')
@UseGuards(JwtAuthGuard)
@ApiTags('æ–‡ç« ç®¡ç†')
export class ArticlesController {
  @Get()
  @CacheResult('articles:list', 300)
  @ApiOperation({ summary: 'è·å–æ–‡ç« åˆ—è¡¨' })
  async findAll(@Query() query: FindArticlesDto) {
    return this.articlesService.findAll(query);
  }
}
```

#### ä¸­é—´ä»¶å’Œæ‹¦æˆªå™¨
```typescript
// æ¨ªåˆ‡å…³æ³¨ç‚¹çš„å¤„ç†
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const start = Date.now();
    return next.handle().pipe(
      tap(() => {
        const duration = Date.now() - start;
        this.logger.log(`Request completed in ${duration}ms`);
      }),
    );
  }
}
```

## ğŸ† æœ€ä½³å®è·µæ€»ç»“

### 1. ä»£ç ç»„ç»‡

#### ç›®å½•ç»“æ„
```
src/
â”œâ”€â”€ common/           # é€šç”¨ç»„ä»¶
â”‚   â”œâ”€â”€ decorators/   # è‡ªå®šä¹‰è£…é¥°å™¨
â”‚   â”œâ”€â”€ filters/      # å¼‚å¸¸è¿‡æ»¤å™¨
â”‚   â”œâ”€â”€ guards/       # å®ˆå«
â”‚   â”œâ”€â”€ interceptors/ # æ‹¦æˆªå™¨
â”‚   â”œâ”€â”€ pipes/        # ç®¡é“
â”‚   â””â”€â”€ utils/        # å·¥å…·å‡½æ•°
â”œâ”€â”€ config/           # é…ç½®æ–‡ä»¶
â”œâ”€â”€ modules/          # ä¸šåŠ¡æ¨¡å—
â”‚   â”œâ”€â”€ auth/
â”‚   â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ articles/
â”‚   â””â”€â”€ ...
â”œâ”€â”€ prisma/           # æ•°æ®åº“ç›¸å…³
â””â”€â”€ test/             # æµ‹è¯•æ–‡ä»¶
```

#### å‘½åè§„èŒƒ
- **æ–‡ä»¶å‘½å**: kebab-case (user-profile.service.ts)
- **ç±»å‘½å**: PascalCase (UserProfileService)
- **æ–¹æ³•å‘½å**: camelCase (getUserProfile)
- **å¸¸é‡å‘½å**: UPPER_SNAKE_CASE (MAX_FILE_SIZE)

### 2. å®‰å…¨æœ€ä½³å®è·µ

#### è¾“å…¥éªŒè¯
```typescript
// ä½¿ç”¨ DTO å’ŒéªŒè¯è£…é¥°å™¨
export class CreateUserDto {
  @IsEmail()
  @ApiProperty({ example: 'user@example.com' })
  email: string;

  @IsString()
  @MinLength(8)
  @Matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
  password: string;
}
```

#### æƒé™æ§åˆ¶
```typescript
// åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
@UseGuards(JwtAuthGuard, RolesGuard)
@Roles(UserRole.ADMIN)
@Delete(':id')
async remove(@Param('id') id: string) {
  return this.usersService.remove(id);
}
```

#### æ•æ„Ÿä¿¡æ¯å¤„ç†
```typescript
// æ’é™¤æ•æ„Ÿå­—æ®µ
@Exclude()
password: string;

@Transform(({ value }) => value ? '***' : null)
phoneNumber: string;
```

### 3. æ€§èƒ½ä¼˜åŒ–

#### æ•°æ®åº“ä¼˜åŒ–
```typescript
// ä½¿ç”¨ç´¢å¼•å’ŒæŸ¥è¯¢ä¼˜åŒ–
const articles = await this.prisma.article.findMany({
  where: { status: 'PUBLISHED' },
  include: {
    author: { select: { id: true, username: true } },
    category: { select: { id: true, name: true } },
    _count: { select: { comments: true } },
  },
  orderBy: { createdAt: 'desc' },
  take: limit,
  skip: (page - 1) * limit,
});
```

#### ç¼“å­˜ç­–ç•¥
```typescript
// å¤šå±‚ç¼“å­˜è®¾è®¡
@CacheResult('articles:list', 300)
async findAll(query: FindArticlesDto) {
  // åº”ç”¨å±‚ç¼“å­˜
  const cacheKey = `articles:${JSON.stringify(query)}`;
  const cached = await this.cacheService.get(cacheKey);
  if (cached) return cached;

  // æ•°æ®åº“æŸ¥è¯¢
  const result = await this.prisma.article.findMany(query);
  await this.cacheService.set(cacheKey, result, 300);
  return result;
}
```

### 4. é”™è¯¯å¤„ç†

#### ç»Ÿä¸€å¼‚å¸¸å¤„ç†
```typescript
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    
    const errorResponse = {
      statusCode: this.getStatus(exception),
      timestamp: new Date().toISOString(),
      path: ctx.getRequest().url,
      message: this.getMessage(exception),
    };
    
    response.status(errorResponse.statusCode).json(errorResponse);
  }
}
```

#### ä¸šåŠ¡å¼‚å¸¸å®šä¹‰
```typescript
export class UserNotFoundException extends NotFoundException {
  constructor(id: string) {
    super(`User with ID ${id} not found`);
  }
}
```

### 5. æµ‹è¯•ç­–ç•¥

#### æµ‹è¯•é‡‘å­—å¡”
```
    /\
   /  \     E2E Tests (å°‘é‡)
  /____\    
 /      \   Integration Tests (é€‚é‡)
/__________\ Unit Tests (å¤§é‡)
```

#### æµ‹è¯•è¦†ç›–ç‡ç›®æ ‡
- **å•å…ƒæµ‹è¯•**: 80%+ è¦†ç›–ç‡
- **é›†æˆæµ‹è¯•**: æ ¸å¿ƒä¸šåŠ¡æµç¨‹ 100% è¦†ç›–
- **E2E æµ‹è¯•**: ä¸»è¦ç”¨æˆ·åœºæ™¯è¦†ç›–

## ğŸš€ é¡¹ç›®æ‰©å±•å»ºè®®

### 1. åŠŸèƒ½æ‰©å±•

#### é«˜çº§å†…å®¹ç®¡ç†
```typescript
// å†…å®¹ç‰ˆæœ¬æ§åˆ¶
@Entity()
export class ArticleVersion {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  articleId: string;

  @Column('text')
  content: string;

  @Column()
  version: number;

  @Column()
  createdAt: Date;

  @ManyToOne(() => User)
  author: User;
}

// å†…å®¹å®¡æ ¸å·¥ä½œæµ
@Entity()
export class ContentReview {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  contentId: string;

  @Column()
  contentType: 'ARTICLE' | 'COMMENT';

  @Column()
  status: 'PENDING' | 'APPROVED' | 'REJECTED';

  @Column({ nullable: true })
  reviewNotes: string;

  @ManyToOne(() => User)
  reviewer: User;
}
```

#### ç¤¾äº¤åŠŸèƒ½
```typescript
// ç”¨æˆ·å…³æ³¨ç³»ç»Ÿ
@Entity()
export class UserFollow {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  followerId: string;

  @Column()
  followingId: string;

  @CreateDateColumn()
  createdAt: Date;

  @ManyToOne(() => User)
  follower: User;

  @ManyToOne(() => User)
  following: User;
}

// æ–‡ç« ç‚¹èµç³»ç»Ÿ
@Entity()
export class ArticleLike {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  userId: string;

  @Column()
  articleId: string;

  @CreateDateColumn()
  createdAt: Date;

  @ManyToOne(() => User)
  user: User;

  @ManyToOne(() => Article)
  article: Article;
}
```

#### é«˜çº§æœç´¢
```typescript
// Elasticsearch é›†æˆ
@Injectable()
export class SearchService {
  constructor(
    @Inject('ELASTICSEARCH_CLIENT')
    private readonly esClient: Client,
  ) {}

  async indexArticle(article: Article) {
    await this.esClient.index({
      index: 'articles',
      id: article.id,
      body: {
        title: article.title,
        content: article.content,
        tags: article.tags.map(tag => tag.name),
        category: article.category.name,
        author: article.author.username,
        createdAt: article.createdAt,
      },
    });
  }

  async searchArticles(query: string, filters?: SearchFilters) {
    const searchQuery = {
      index: 'articles',
      body: {
        query: {
          bool: {
            must: [
              {
                multi_match: {
                  query,
                  fields: ['title^2', 'content', 'tags'],
                  fuzziness: 'AUTO',
                },
              },
            ],
            filter: this.buildFilters(filters),
          },
        },
        highlight: {
          fields: {
            title: {},
            content: {},
          },
        },
        sort: [
          { _score: { order: 'desc' } },
          { createdAt: { order: 'desc' } },
        ],
      },
    };

    return this.esClient.search(searchQuery);
  }
}
```

### 2. æ¶æ„å‡çº§

#### å¾®æœåŠ¡æ¶æ„
```typescript
// æœåŠ¡æ‹†åˆ†å»ºè®®
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User Service  â”‚    â”‚  Content Service â”‚
â”‚                 â”‚    â”‚                 â”‚
â”‚ - ç”¨æˆ·ç®¡ç†      â”‚    â”‚ - æ–‡ç« ç®¡ç†      â”‚
â”‚ - è®¤è¯æˆæƒ      â”‚    â”‚ - åˆ†ç±»æ ‡ç­¾      â”‚
â”‚ - ä¸ªäººèµ„æ–™      â”‚    â”‚ - è¯„è®ºç³»ç»Ÿ      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Notification    â”‚
         â”‚ Service         â”‚
         â”‚                 â”‚
         â”‚ - é‚®ä»¶é€šçŸ¥      â”‚
         â”‚ - æ¨é€é€šçŸ¥      â”‚
         â”‚ - æ¶ˆæ¯é˜Ÿåˆ—      â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### äº‹ä»¶é©±åŠ¨æ¶æ„
```typescript
// äº‹ä»¶å‘å¸ƒ
@Injectable()
export class ArticlesService {
  constructor(
    private eventEmitter: EventEmitter2,
  ) {}

  async create(createArticleDto: CreateArticleDto) {
    const article = await this.prisma.article.create({
      data: createArticleDto,
    });

    // å‘å¸ƒäº‹ä»¶
    this.eventEmitter.emit('article.created', {
      articleId: article.id,
      authorId: article.authorId,
      title: article.title,
    });

    return article;
  }
}

// äº‹ä»¶ç›‘å¬
@Injectable()
export class NotificationService {
  @OnEvent('article.created')
  async handleArticleCreated(payload: ArticleCreatedEvent) {
    // é€šçŸ¥å…³æ³¨è€…
    await this.notifyFollowers(payload.authorId, payload);

    // å‘é€é‚®ä»¶
    await this.sendNewArticleEmail(payload);

    // æ›´æ–°æœç´¢ç´¢å¼•
    await this.updateSearchIndex(payload.articleId);
  }
}
```

#### æ¶ˆæ¯é˜Ÿåˆ—é›†æˆ
```typescript
// Bull Queue é›†æˆ
@Injectable()
export class EmailService {
  constructor(
    @InjectQueue('email') private emailQueue: Queue,
  ) {}

  async sendWelcomeEmail(user: User) {
    await this.emailQueue.add('welcome', {
      userId: user.id,
      email: user.email,
      name: user.firstName,
    }, {
      delay: 5000, // å»¶è¿Ÿ5ç§’å‘é€
      attempts: 3,
      backoff: 'exponential',
    });
  }
}

@Processor('email')
export class EmailProcessor {
  @Process('welcome')
  async handleWelcomeEmail(job: Job<WelcomeEmailData>) {
    const { email, name } = job.data;

    await this.mailerService.sendMail({
      to: email,
      subject: 'æ¬¢è¿åŠ å…¥æˆ‘ä»¬ï¼',
      template: 'welcome',
      context: { name },
    });
  }
}
```

### 3. æ€§èƒ½ä¼˜åŒ–è¿›é˜¶

#### æ•°æ®åº“åˆ†ç‰‡
```typescript
// è¯»å†™åˆ†ç¦»é…ç½®
@Module({
  imports: [
    TypeOrmModule.forRoot({
      name: 'master',
      type: 'mysql',
      host: 'master-db-host',
      // ... å†™åº“é…ç½®
    }),
    TypeOrmModule.forRoot({
      name: 'slave',
      type: 'mysql',
      host: 'slave-db-host',
      // ... è¯»åº“é…ç½®
    }),
  ],
})
export class DatabaseModule {}

// è¯»å†™åˆ†ç¦»æœåŠ¡
@Injectable()
export class ArticlesService {
  constructor(
    @InjectRepository(Article, 'master')
    private masterRepo: Repository<Article>,
    @InjectRepository(Article, 'slave')
    private slaveRepo: Repository<Article>,
  ) {}

  async create(data: CreateArticleDto) {
    return this.masterRepo.save(data); // å†™æ“ä½œä½¿ç”¨ä¸»åº“
  }

  async findAll(query: FindArticlesDto) {
    return this.slaveRepo.find(query); // è¯»æ“ä½œä½¿ç”¨ä»åº“
  }
}
```

#### CDN é›†æˆ
```typescript
// æ–‡ä»¶ä¸Šä¼ åˆ° CDN
@Injectable()
export class FileUploadService {
  constructor(
    private awsS3: S3,
    private configService: ConfigService,
  ) {}

  async uploadToS3(file: Express.Multer.File): Promise<string> {
    const key = `uploads/${Date.now()}-${file.originalname}`;

    await this.awsS3.upload({
      Bucket: this.configService.get('aws.s3.bucket'),
      Key: key,
      Body: file.buffer,
      ContentType: file.mimetype,
      ACL: 'public-read',
    }).promise();

    return `${this.configService.get('aws.s3.cdnUrl')}/${key}`;
  }
}
```

### 4. å®‰å…¨å¢å¼º

#### API é™æµå‡çº§
```typescript
// æ™ºèƒ½é™æµ
@Injectable()
export class SmartThrottleGuard implements CanActivate {
  constructor(
    private redis: Redis,
    private configService: ConfigService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const endpoint = request.route.path;

    // æ ¹æ®ç”¨æˆ·ç­‰çº§å’Œç«¯ç‚¹ç±»å‹è®¾ç½®ä¸åŒé™åˆ¶
    const limits = this.getLimits(user?.role, endpoint);
    const key = `throttle:${user?.id || request.ip}:${endpoint}`;

    const current = await this.redis.incr(key);
    if (current === 1) {
      await this.redis.expire(key, limits.window);
    }

    return current <= limits.max;
  }

  private getLimits(role: string, endpoint: string) {
    const baseLimits = {
      '/api/auth/login': { max: 5, window: 900 }, // 15åˆ†é’Ÿ5æ¬¡
      '/api/articles': { max: 100, window: 3600 }, // 1å°æ—¶100æ¬¡
    };

    const roleMultipliers = {
      'ADMIN': 10,
      'PREMIUM': 5,
      'USER': 1,
    };

    const baseLimit = baseLimits[endpoint] || { max: 60, window: 3600 };
    const multiplier = roleMultipliers[role] || 1;

    return {
      max: baseLimit.max * multiplier,
      window: baseLimit.window,
    };
  }
}
```

#### å†…å®¹å®‰å…¨ç­–ç•¥
```typescript
// XSS é˜²æŠ¤
@Injectable()
export class ContentSanitizer {
  private sanitizeHtml = require('sanitize-html');

  sanitizeContent(content: string): string {
    return this.sanitizeHtml(content, {
      allowedTags: [
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
        'p', 'br', 'strong', 'em', 'u', 's',
        'ul', 'ol', 'li',
        'blockquote', 'code', 'pre',
        'a', 'img',
      ],
      allowedAttributes: {
        'a': ['href', 'title'],
        'img': ['src', 'alt', 'title', 'width', 'height'],
      },
      allowedSchemes: ['http', 'https', 'mailto'],
    });
  }
}
```

## ğŸ“š å­¦ä¹ è·¯å¾„å»ºè®®

### 1. åˆçº§å¼€å‘è€… (0-1å¹´)

#### åŸºç¡€çŸ¥è¯†
- **JavaScript/TypeScript åŸºç¡€**
  - ES6+ è¯­æ³•ç‰¹æ€§
  - Promise å’Œ async/await
  - ç±»å‹ç³»ç»Ÿå’Œæ³›å‹

- **Node.js ç”Ÿæ€**
  - npm/yarn åŒ…ç®¡ç†
  - æ¨¡å—ç³»ç»Ÿ
  - å¼‚æ­¥ç¼–ç¨‹æ¨¡å¼

- **NestJS æ ¸å¿ƒæ¦‚å¿µ**
  - ä¾èµ–æ³¨å…¥
  - è£…é¥°å™¨æ¨¡å¼
  - æ¨¡å—åŒ–æ¶æ„

#### å®è·µé¡¹ç›®
1. **ç®€å• CRUD API**: ç”¨æˆ·ç®¡ç†ç³»ç»Ÿ
2. **è®¤è¯ç³»ç»Ÿ**: JWT ç™»å½•æ³¨å†Œ
3. **æ–‡ä»¶ä¸Šä¼ **: å›¾ç‰‡å¤„ç†å’Œå­˜å‚¨

### 2. ä¸­çº§å¼€å‘è€… (1-3å¹´)

#### è¿›é˜¶æŠ€èƒ½
- **æ•°æ®åº“è®¾è®¡**
  - å…³ç³»å‹æ•°æ®åº“è®¾è®¡
  - ORM ä½¿ç”¨å’Œä¼˜åŒ–
  - æ•°æ®è¿ç§»ç­–ç•¥

- **æµ‹è¯•é©±åŠ¨å¼€å‘**
  - å•å…ƒæµ‹è¯•ç¼–å†™
  - é›†æˆæµ‹è¯•è®¾è®¡
  - æµ‹è¯•è¦†ç›–ç‡ç®¡ç†

- **API è®¾è®¡**
  - RESTful è®¾è®¡åŸåˆ™
  - GraphQL åŸºç¡€
  - API ç‰ˆæœ¬ç®¡ç†

#### å®è·µé¡¹ç›®
1. **åšå®¢ç³»ç»Ÿ**: å®Œæ•´çš„å†…å®¹ç®¡ç†
2. **ç”µå•† API**: è®¢å•å’Œæ”¯ä»˜ç³»ç»Ÿ
3. **å®æ—¶èŠå¤©**: WebSocket åº”ç”¨

### 3. é«˜çº§å¼€å‘è€… (3-5å¹´)

#### æ¶æ„è®¾è®¡
- **å¾®æœåŠ¡æ¶æ„**
  - æœåŠ¡æ‹†åˆ†ç­–ç•¥
  - æœåŠ¡é—´é€šä¿¡
  - åˆ†å¸ƒå¼äº‹åŠ¡

- **æ€§èƒ½ä¼˜åŒ–**
  - ç¼“å­˜ç­–ç•¥è®¾è®¡
  - æ•°æ®åº“ä¼˜åŒ–
  - è´Ÿè½½å‡è¡¡

- **DevOps å®è·µ**
  - å®¹å™¨åŒ–éƒ¨ç½²
  - CI/CD æµæ°´çº¿
  - ç›‘æ§å’Œæ—¥å¿—

#### å®è·µé¡¹ç›®
1. **å¾®æœåŠ¡å¹³å°**: å¤šæœåŠ¡åä½œ
2. **é«˜å¹¶å‘ç³»ç»Ÿ**: ç§’æ€ç³»ç»Ÿ
3. **æ•°æ®åˆ†æå¹³å°**: å¤§æ•°æ®å¤„ç†

## â“ å¸¸è§é—®é¢˜ä¸è§£å†³æ–¹æ¡ˆ

### 1. å¼€å‘ç¯å¢ƒé—®é¢˜

#### é—®é¢˜ï¼šPrisma å®¢æˆ·ç«¯ç”Ÿæˆå¤±è´¥
```bash
# é”™è¯¯ä¿¡æ¯
Error: Generator "client" failed:
/usr/lib/x86_64-linux-gnu/libssl.so.1.1: version `OPENSSL_1_1_1' not found
```

**è§£å†³æ–¹æ¡ˆï¼š**
```bash
# æ–¹æ¡ˆ1ï¼šæ›´æ–° Prisma
npm update @prisma/client prisma

# æ–¹æ¡ˆ2ï¼šä½¿ç”¨äºŒè¿›åˆ¶ç›®æ ‡
# prisma/schema.prisma
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl"]
}

# æ–¹æ¡ˆ3ï¼šæ¸…ç†å¹¶é‡æ–°ç”Ÿæˆ
rm -rf node_modules/.prisma
npx prisma generate
```

#### é—®é¢˜ï¼šTypeScript ç¼–è¯‘é”™è¯¯
```typescript
// é”™è¯¯ï¼šè£…é¥°å™¨å…ƒæ•°æ®é—®é¢˜
error TS1219: Experimental support for decorators is a feature that is subject to change
```

**è§£å†³æ–¹æ¡ˆï¼š**
```json
// tsconfig.json
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "strictPropertyInitialization": false
  }
}
```

### 2. æ•°æ®åº“ç›¸å…³é—®é¢˜

#### é—®é¢˜ï¼šè¿æ¥æ± è€—å°½
```
Error: Can't reach database server at `localhost:3306`
Too many connections
```

**è§£å†³æ–¹æ¡ˆï¼š**
```typescript
// ä¼˜åŒ–è¿æ¥æ± é…ç½®
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: process.env.DATABASE_URL,
    },
  },
  log: ['query', 'info', 'warn', 'error'],
});

// åœ¨åº”ç”¨å…³é—­æ—¶æ–­å¼€è¿æ¥
process.on('beforeExit', async () => {
  await prisma.$disconnect();
});
```

#### é—®é¢˜ï¼šæ•°æ®åº“è¿ç§»å†²çª
```bash
# é”™è¯¯ä¿¡æ¯
Migration `20231201000000_init` failed to apply cleanly to the shadow database
```

**è§£å†³æ–¹æ¡ˆï¼š**
```bash
# é‡ç½®æ•°æ®åº“ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
npx prisma migrate reset

# æˆ–è€…æ‰‹åŠ¨è§£å†³å†²çª
npx prisma db push --force-reset

# ç”Ÿäº§ç¯å¢ƒè°¨æ…æ“ä½œ
npx prisma migrate resolve --applied 20231201000000_init
```

### 3. è®¤è¯æˆæƒé—®é¢˜

#### é—®é¢˜ï¼šJWT ä»¤ç‰Œè¿‡æœŸå¤„ç†
```typescript
// é—®é¢˜ï¼šç”¨æˆ·ä½“éªŒå·®ï¼Œé¢‘ç¹è¦æ±‚é‡æ–°ç™»å½•
```

**è§£å†³æ–¹æ¡ˆï¼š**
```typescript
// å®ç°è‡ªåŠ¨åˆ·æ–°æœºåˆ¶
@Injectable()
export class JwtRefreshGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private authService: AuthService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);

    if (!token) {
      throw new UnauthorizedException();
    }

    try {
      const payload = this.jwtService.verify(token);
      request.user = payload;
      return true;
    } catch (error) {
      if (error.name === 'TokenExpiredError') {
        // å°è¯•ä½¿ç”¨åˆ·æ–°ä»¤ç‰Œ
        const refreshToken = request.headers['x-refresh-token'];
        if (refreshToken) {
          const newTokens = await this.authService.refreshTokens(refreshToken);
          request.headers.authorization = `Bearer ${newTokens.accessToken}`;
          return true;
        }
      }
      throw new UnauthorizedException();
    }
  }
}
```

### 4. æ€§èƒ½ä¼˜åŒ–é—®é¢˜

#### é—®é¢˜ï¼šN+1 æŸ¥è¯¢é—®é¢˜
```typescript
// é—®é¢˜ä»£ç ï¼šæ¯ä¸ªæ–‡ç« éƒ½ä¼šå•ç‹¬æŸ¥è¯¢ä½œè€…ä¿¡æ¯
const articles = await this.prisma.article.findMany();
for (const article of articles) {
  article.author = await this.prisma.user.findUnique({
    where: { id: article.authorId }
  });
}
```

**è§£å†³æ–¹æ¡ˆï¼š**
```typescript
// ä½¿ç”¨ include æˆ– select é¢„åŠ è½½å…³è”æ•°æ®
const articles = await this.prisma.article.findMany({
  include: {
    author: {
      select: {
        id: true,
        username: true,
        avatar: true,
      },
    },
    category: true,
    tags: true,
    _count: {
      select: {
        comments: true,
        likes: true,
      },
    },
  },
});
```

#### é—®é¢˜ï¼šå†…å­˜æ³„æ¼
```typescript
// é—®é¢˜ï¼šäº‹ä»¶ç›‘å¬å™¨æœªæ­£ç¡®æ¸…ç†
```

**è§£å†³æ–¹æ¡ˆï¼š**
```typescript
@Injectable()
export class SomeService implements OnModuleDestroy {
  private eventListeners: Array<() => void> = [];

  constructor() {
    const listener = () => { /* ... */ };
    process.on('SIGTERM', listener);
    this.eventListeners.push(() => process.off('SIGTERM', listener));
  }

  onModuleDestroy() {
    // æ¸…ç†æ‰€æœ‰ç›‘å¬å™¨
    this.eventListeners.forEach(cleanup => cleanup());
  }
}
```

### 5. éƒ¨ç½²ç›¸å…³é—®é¢˜

#### é—®é¢˜ï¼šDocker æ„å»ºç¼“æ…¢
```dockerfile
# é—®é¢˜ï¼šæ¯æ¬¡éƒ½é‡æ–°å®‰è£…ä¾èµ–
COPY . .
RUN npm install
```

**è§£å†³æ–¹æ¡ˆï¼š**
```dockerfile
# ä¼˜åŒ–ï¼šåˆ©ç”¨ Docker å±‚ç¼“å­˜
COPY package*.json ./
RUN npm ci --only=production

COPY . .
RUN npm run build
```

#### é—®é¢˜ï¼šç”Ÿäº§ç¯å¢ƒé…ç½®ç®¡ç†
```typescript
// é—®é¢˜ï¼šæ•æ„Ÿä¿¡æ¯ç¡¬ç¼–ç 
const config = {
  jwt: {
    secret: 'hardcoded-secret', // ä¸å®‰å…¨
  },
};
```

**è§£å†³æ–¹æ¡ˆï¼š**
```typescript
// ä½¿ç”¨ç¯å¢ƒå˜é‡å’Œé…ç½®éªŒè¯
import { IsString, IsNumber, validateSync } from 'class-validator';
import { plainToClass, Transform } from 'class-transformer';

class EnvironmentVariables {
  @IsString()
  JWT_SECRET: string;

  @IsString()
  DATABASE_URL: string;

  @IsNumber()
  @Transform(({ value }) => parseInt(value))
  PORT: number;
}

export function validate(config: Record<string, unknown>) {
  const validatedConfig = plainToClass(EnvironmentVariables, config, {
    enableImplicitConversion: true,
  });

  const errors = validateSync(validatedConfig, {
    skipMissingProperties: false,
  });

  if (errors.length > 0) {
    throw new Error(errors.toString());
  }

  return validatedConfig;
}
```

## ğŸ”§ è°ƒè¯•æŠ€å·§

### 1. æ—¥å¿—è°ƒè¯•
```typescript
// ç»“æ„åŒ–æ—¥å¿—
@Injectable()
export class ArticlesService {
  private readonly logger = new Logger(ArticlesService.name);

  async create(createArticleDto: CreateArticleDto) {
    this.logger.log('Creating article', {
      title: createArticleDto.title,
      authorId: createArticleDto.authorId,
    });

    try {
      const article = await this.prisma.article.create({
        data: createArticleDto,
      });

      this.logger.log('Article created successfully', {
        articleId: article.id,
      });

      return article;
    } catch (error) {
      this.logger.error('Failed to create article', {
        error: error.message,
        stack: error.stack,
        input: createArticleDto,
      });
      throw error;
    }
  }
}
```

### 2. æ•°æ®åº“æŸ¥è¯¢è°ƒè¯•
```typescript
// Prisma æŸ¥è¯¢æ—¥å¿—
const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
    {
      emit: 'stdout',
      level: 'error',
    },
    {
      emit: 'stdout',
      level: 'info',
    },
    {
      emit: 'stdout',
      level: 'warn',
    },
  ],
});

prisma.$on('query', (e) => {
  console.log('Query: ' + e.query);
  console.log('Params: ' + e.params);
  console.log('Duration: ' + e.duration + 'ms');
});
```

### 3. API æµ‹è¯•è°ƒè¯•
```typescript
// æµ‹è¯•è¾…åŠ©å·¥å…·
export class TestHelper {
  static async createTestUser(app: INestApplication) {
    const response = await request(app.getHttpServer())
      .post('/auth/register')
      .send({
        email: 'test@example.com',
        username: 'testuser',
        password: 'password123',
      });

    return {
      user: response.body.user,
      token: response.body.accessToken,
    };
  }

  static async authenticatedRequest(
    app: INestApplication,
    method: 'get' | 'post' | 'put' | 'delete',
    url: string,
    token: string,
    data?: any,
  ) {
    const req = request(app.getHttpServer())[method](url)
      .set('Authorization', `Bearer ${token}`);

    if (data) {
      req.send(data);
    }

    return req;
  }
}
```

## ğŸ“ æ€»ç»“

é€šè¿‡è¿™ä¸ªå®Œæ•´çš„ NestJS æ•™ç¨‹ï¼Œæˆ‘ä»¬ä»é›¶å¼€å§‹æ„å»ºäº†ä¸€ä¸ªä¼ä¸šçº§çš„åšå®¢ç³»ç»Ÿã€‚è¿™ä¸ªé¡¹ç›®æ¶µç›–äº†ç°ä»£ Web å¼€å‘çš„å„ä¸ªæ–¹é¢ï¼š

### âœ… æˆ‘ä»¬å­¦åˆ°äº†ä»€ä¹ˆ

1. **NestJS æ¡†æ¶ç²¾é«“**
   - æ¨¡å—åŒ–æ¶æ„è®¾è®¡
   - ä¾èµ–æ³¨å…¥å’Œè£…é¥°å™¨
   - ä¸­é—´ä»¶å’Œæ‹¦æˆªå™¨

2. **ä¼ä¸šçº§å¼€å‘å®è·µ**
   - ä»£ç ç»„ç»‡å’Œè§„èŒƒ
   - é”™è¯¯å¤„ç†å’Œæ—¥å¿—
   - å®‰å…¨æœ€ä½³å®è·µ

3. **æ•°æ®åº“è®¾è®¡å’Œä¼˜åŒ–**
   - Prisma ORM ä½¿ç”¨
   - æŸ¥è¯¢ä¼˜åŒ–æŠ€å·§
   - æ•°æ®è¿ç§»ç­–ç•¥

4. **æµ‹è¯•é©±åŠ¨å¼€å‘**
   - å•å…ƒæµ‹è¯•ç¼–å†™
   - é›†æˆæµ‹è¯•è®¾è®¡
   - E2E æµ‹è¯•å®ç°

5. **éƒ¨ç½²å’Œè¿ç»´**
   - Docker å®¹å™¨åŒ–
   - CI/CD æµæ°´çº¿
   - ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

### ğŸš€ ä¸‹ä¸€æ­¥å»ºè®®

1. **æ·±å…¥å­¦ä¹ **
   - é˜…è¯» NestJS å®˜æ–¹æ–‡æ¡£
   - ç ”ç©¶å¼€æºé¡¹ç›®æºç 
   - å‚ä¸ç¤¾åŒºè®¨è®º

2. **å®è·µé¡¹ç›®**
   - åŸºäºæœ¬æ•™ç¨‹æ‰©å±•åŠŸèƒ½
   - å°è¯•ä¸åŒçš„æŠ€æœ¯æ ˆç»„åˆ
   - å‚ä¸å¼€æºé¡¹ç›®è´¡çŒ®

3. **æŒç»­æ”¹è¿›**
   - å…³æ³¨æœ€æ–°æŠ€æœ¯è¶‹åŠ¿
   - å­¦ä¹ æ¶æ„è®¾è®¡æ¨¡å¼
   - æå‡ä»£ç è´¨é‡æ„è¯†

### ğŸ’¡ æœ€åçš„è¯

è½¯ä»¶å¼€å‘æ˜¯ä¸€ä¸ªä¸æ–­å­¦ä¹ å’Œå®è·µçš„è¿‡ç¨‹ã€‚è¿™ä¸ªæ•™ç¨‹åªæ˜¯ä¸€ä¸ªèµ·ç‚¹ï¼ŒçœŸæ­£çš„æˆé•¿æ¥è‡ªäºåœ¨å®é™…é¡¹ç›®ä¸­çš„åº”ç”¨å’Œæ€è€ƒã€‚å¸Œæœ›è¿™ä¸ªæ•™ç¨‹èƒ½å¤Ÿå¸®åŠ©ä½ åœ¨ NestJS çš„å­¦ä¹ é“è·¯ä¸Šæ›´è¿›ä¸€æ­¥ï¼

è®°ä½ï¼š**æœ€å¥½çš„ä»£ç ä¸æ˜¯æœ€å¤æ‚çš„ï¼Œè€Œæ˜¯æœ€å®¹æ˜“ç†è§£å’Œç»´æŠ¤çš„ã€‚**

ç¥ä½ åœ¨ NestJS çš„å­¦ä¹ å’Œå¼€å‘ä¸­å–å¾—æˆåŠŸï¼ğŸ‰

# Á¨¨5Á´†ÔºöÊñáÁ´†ÁÆ°ÁêÜÊ®°Âùó

## üéØ Êú¨Á´†ÁõÆÊ†á

Âú®Ëøô‰∏ÄÁ´†‰∏≠ÔºåÊàë‰ª¨Â∞ÜÔºö
- ÂàõÂª∫ÊñáÁ´†ÁÆ°ÁêÜÊ®°Âùó
- ÂÆûÁé∞ÊñáÁ´†ÁöÑ CRUD Êìç‰Ωú
- ÂàõÂª∫ÂàÜÁ±ªÂíåÊ†áÁ≠æÁÆ°ÁêÜ
- ÂÆûÁé∞ÊñáÁ´†ÊêúÁ¥¢ÂíåÂàÜÈ°µ
- ÂàõÂª∫ËØÑËÆ∫Á≥ªÁªü
- ÂÆûÁé∞ÊñáÁ´†Áä∂ÊÄÅÁÆ°ÁêÜ

## üìÅ ÂàõÂª∫Ê®°ÂùóÁªìÊûÑ

### 1. ÁîüÊàêÊñáÁ´†Áõ∏ÂÖ≥Ê®°Âùó

```bash
# ÁîüÊàêÊñáÁ´†Ê®°Âùó
nest g mo modules/articles
nest g s modules/articles
nest g co modules/articles

# ÁîüÊàêÂàÜÁ±ªÊ®°Âùó
nest g mo modules/categories
nest g s modules/categories
nest g co modules/categories

# ÁîüÊàêÊ†áÁ≠æÊ®°Âùó
nest g mo modules/tags
nest g s modules/tags
nest g co modules/tags

# ÁîüÊàêËØÑËÆ∫Ê®°Âùó
nest g mo modules/comments
nest g s modules/comments
nest g co modules/comments
```

### 2. ÂàõÂª∫ÁõÆÂΩïÁªìÊûÑ

```
src/modules/
‚îú‚îÄ‚îÄ articles/
‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ create-article.dto.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ update-article.dto.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ query-article.dto.ts
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ article.entity.ts
‚îÇ   ‚îú‚îÄ‚îÄ articles.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ articles.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ articles.module.ts
‚îú‚îÄ‚îÄ categories/
‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îú‚îÄ‚îÄ categories.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ categories.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ categories.module.ts
‚îú‚îÄ‚îÄ tags/
‚îÇ   ‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ entities/
‚îÇ   ‚îú‚îÄ‚îÄ tags.controller.ts
‚îÇ   ‚îú‚îÄ‚îÄ tags.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ tags.module.ts
‚îî‚îÄ‚îÄ comments/
    ‚îú‚îÄ‚îÄ dto/
    ‚îú‚îÄ‚îÄ entities/
    ‚îú‚îÄ‚îÄ comments.controller.ts
    ‚îú‚îÄ‚îÄ comments.service.ts
    ‚îî‚îÄ‚îÄ comments.module.ts
```

## üìù ÂàõÂª∫ÊñáÁ´† DTO

### 1. ÊñáÁ´†ÂàõÂª∫ÂíåÊõ¥Êñ∞ DTO

```typescript
// src/modules/articles/dto/create-article.dto.ts
import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsBoolean,
  IsArray,
  IsUUID,
  MaxLength,
  MinLength,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
import { ArticleStatus } from '@prisma/client';

export class CreateArticleDto {
  @ApiProperty({ 
    description: 'ÊñáÁ´†Ê†áÈ¢ò',
    example: 'NestJS ÂÆûÊàòÊåáÂçó',
    maxLength: 255
  })
  @IsString({ message: 'Ê†áÈ¢òÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @IsNotEmpty({ message: 'Ê†áÈ¢ò‰∏çËÉΩ‰∏∫Á©∫' })
  @MaxLength(255, { message: 'Ê†áÈ¢òÊúÄÂ§ö255‰∏™Â≠óÁ¨¶' })
  title: string;

  @ApiProperty({ 
    description: 'ÊñáÁ´†ÂÜÖÂÆπ',
    example: 'ËøôÊòØ‰∏ÄÁØáÂÖ≥‰∫é NestJS ÁöÑËØ¶ÁªÜÊïôÁ®ã...'
  })
  @IsString({ message: 'ÂÜÖÂÆπÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @IsNotEmpty({ message: 'ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫' })
  content: string;

  @ApiPropertyOptional({ 
    description: 'ÊñáÁ´†ÊëòË¶Å',
    maxLength: 500
  })
  @IsOptional()
  @IsString({ message: 'ÊëòË¶ÅÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(500, { message: 'ÊëòË¶ÅÊúÄÂ§ö500‰∏™Â≠óÁ¨¶' })
  excerpt?: string;

  @ApiPropertyOptional({ 
    description: 'Â∞ÅÈù¢ÂõæÁâáURL'
  })
  @IsOptional()
  @IsString({ message: 'Â∞ÅÈù¢ÂõæÁâáURLÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  coverImage?: string;

  @ApiProperty({ 
    description: 'ÂàÜÁ±ªID',
    format: 'uuid'
  })
  @IsUUID(4, { message: 'ÂàÜÁ±ªIDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  @IsNotEmpty({ message: 'ÂàÜÁ±ªID‰∏çËÉΩ‰∏∫Á©∫' })
  categoryId: string;

  @ApiPropertyOptional({ 
    description: 'Ê†áÁ≠æIDÂàóË°®',
    type: [String]
  })
  @IsOptional()
  @IsArray({ message: 'Ê†áÁ≠æIDÂøÖÈ°ªÊòØÊï∞ÁªÑ' })
  @IsUUID(4, { each: true, message: 'ÊØè‰∏™Ê†áÁ≠æIDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  tagIds?: string[];

  @ApiPropertyOptional({ 
    description: 'ÊñáÁ´†Áä∂ÊÄÅ',
    enum: ArticleStatus,
    default: ArticleStatus.DRAFT
  })
  @IsOptional()
  status?: ArticleStatus;

  @ApiPropertyOptional({ 
    description: 'ÊòØÂê¶ÂÖÅËÆ∏ËØÑËÆ∫',
    default: true
  })
  @IsOptional()
  @IsBoolean({ message: 'ÂÖÅËÆ∏ËØÑËÆ∫ÂøÖÈ°ªÊòØÂ∏ÉÂ∞îÂÄº' })
  allowComments?: boolean;

  @ApiPropertyOptional({ 
    description: 'ÊòØÂê¶ÁΩÆÈ°∂',
    default: false
  })
  @IsOptional()
  @IsBoolean({ message: 'ÁΩÆÈ°∂ÂøÖÈ°ªÊòØÂ∏ÉÂ∞îÂÄº' })
  isPinned?: boolean;

  @ApiPropertyOptional({ 
    description: 'ÊòØÂê¶Êé®Ëçê',
    default: false
  })
  @IsOptional()
  @IsBoolean({ message: 'Êé®ËçêÂøÖÈ°ªÊòØÂ∏ÉÂ∞îÂÄº' })
  isFeatured?: boolean;

  // SEO Áõ∏ÂÖ≥Â≠óÊÆµ
  @ApiPropertyOptional({ 
    description: 'SEOÊ†áÈ¢ò',
    maxLength: 255
  })
  @IsOptional()
  @IsString({ message: 'SEOÊ†áÈ¢òÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(255, { message: 'SEOÊ†áÈ¢òÊúÄÂ§ö255‰∏™Â≠óÁ¨¶' })
  metaTitle?: string;

  @ApiPropertyOptional({ 
    description: 'SEOÊèèËø∞',
    maxLength: 500
  })
  @IsOptional()
  @IsString({ message: 'SEOÊèèËø∞ÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(500, { message: 'SEOÊèèËø∞ÊúÄÂ§ö500‰∏™Â≠óÁ¨¶' })
  metaDescription?: string;

  @ApiPropertyOptional({ 
    description: 'SEOÂÖ≥ÈîÆËØç'
  })
  @IsOptional()
  @IsString({ message: 'SEOÂÖ≥ÈîÆËØçÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  metaKeywords?: string;
}
```

```typescript
// src/modules/articles/dto/update-article.dto.ts
import { PartialType } from '@nestjs/swagger';
import { CreateArticleDto } from './create-article.dto';

export class UpdateArticleDto extends PartialType(CreateArticleDto) {}
```

```typescript
// src/modules/articles/dto/query-article.dto.ts
import {
  IsOptional,
  IsString,
  IsEnum,
  IsInt,
  Min,
  Max,
  IsBoolean,
  IsUUID,
} from 'class-validator';
import { Type, Transform } from 'class-transformer';
import { ApiPropertyOptional } from '@nestjs/swagger';
import { ArticleStatus } from '@prisma/client';

export class QueryArticleDto {
  @ApiPropertyOptional({ 
    description: 'È°µÁ†Å', 
    default: 1, 
    minimum: 1 
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: 'È°µÁ†ÅÂøÖÈ°ªÊòØÊï¥Êï∞' })
  @Min(1, { message: 'È°µÁ†ÅÊúÄÂ∞è‰∏∫1' })
  page?: number = 1;

  @ApiPropertyOptional({ 
    description: 'ÊØèÈ°µÊï∞Èáè', 
    default: 10, 
    minimum: 1, 
    maximum: 100 
  })
  @IsOptional()
  @Type(() => Number)
  @IsInt({ message: 'ÊØèÈ°µÊï∞ÈáèÂøÖÈ°ªÊòØÊï¥Êï∞' })
  @Min(1, { message: 'ÊØèÈ°µÊï∞ÈáèÊúÄÂ∞è‰∏∫1' })
  @Max(100, { message: 'ÊØèÈ°µÊï∞ÈáèÊúÄÂ§ß‰∏∫100' })
  limit?: number = 10;

  @ApiPropertyOptional({ description: 'ÊêúÁ¥¢ÂÖ≥ÈîÆËØç' })
  @IsOptional()
  @IsString({ message: 'ÊêúÁ¥¢ÂÖ≥ÈîÆËØçÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  search?: string;

  @ApiPropertyOptional({ 
    description: 'ÊñáÁ´†Áä∂ÊÄÅ', 
    enum: ArticleStatus 
  })
  @IsOptional()
  @IsEnum(ArticleStatus, { message: 'Êó†ÊïàÁöÑÊñáÁ´†Áä∂ÊÄÅ' })
  status?: ArticleStatus;

  @ApiPropertyOptional({ 
    description: 'ÂàÜÁ±ªID',
    format: 'uuid'
  })
  @IsOptional()
  @IsUUID(4, { message: 'ÂàÜÁ±ªIDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  categoryId?: string;

  @ApiPropertyOptional({ 
    description: 'Ê†áÁ≠æID',
    format: 'uuid'
  })
  @IsOptional()
  @IsUUID(4, { message: 'Ê†áÁ≠æIDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  tagId?: string;

  @ApiPropertyOptional({ 
    description: '‰ΩúËÄÖID',
    format: 'uuid'
  })
  @IsOptional()
  @IsUUID(4, { message: '‰ΩúËÄÖIDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  authorId?: string;

  @ApiPropertyOptional({ 
    description: 'ÊòØÂê¶Âè™ÊòæÁ§∫ÁΩÆÈ°∂ÊñáÁ´†'
  })
  @IsOptional()
  @Transform(({ value }) => value === 'true')
  @IsBoolean({ message: 'ÁΩÆÈ°∂Áä∂ÊÄÅÂøÖÈ°ªÊòØÂ∏ÉÂ∞îÂÄº' })
  isPinned?: boolean;

  @ApiPropertyOptional({ 
    description: 'ÊòØÂê¶Âè™ÊòæÁ§∫Êé®ËçêÊñáÁ´†'
  })
  @IsOptional()
  @Transform(({ value }) => value === 'true')
  @IsBoolean({ message: 'Êé®ËçêÁä∂ÊÄÅÂøÖÈ°ªÊòØÂ∏ÉÂ∞îÂÄº' })
  isFeatured?: boolean;

  @ApiPropertyOptional({ 
    description: 'ÊéíÂ∫èÂ≠óÊÆµ',
    default: 'createdAt',
    enum: ['createdAt', 'updatedAt', 'publishedAt', 'viewCount', 'likeCount', 'title']
  })
  @IsOptional()
  @IsString({ message: 'ÊéíÂ∫èÂ≠óÊÆµÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  sortBy?: string = 'createdAt';

  @ApiPropertyOptional({ 
    description: 'ÊéíÂ∫èÊñπÂêë',
    enum: ['asc', 'desc'],
    default: 'desc'
  })
  @IsOptional()
  @IsString({ message: 'ÊéíÂ∫èÊñπÂêëÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  sortOrder?: 'asc' | 'desc' = 'desc';
}
```

## üèóÔ∏è ÂàõÂª∫ÊñáÁ´†ÂÆû‰Ωì

```typescript
// src/modules/articles/entities/article.entity.ts
import { Article, ArticleStatus } from '@prisma/client';
import { ApiProperty } from '@nestjs/swagger';
import { UserEntity } from '../../users/entities/user.entity';

export class ArticleEntity implements Article {
  @ApiProperty()
  id: string;

  @ApiProperty()
  title: string;

  @ApiProperty()
  slug: string;

  @ApiProperty()
  content: string;

  @ApiProperty({ required: false })
  excerpt: string | null;

  @ApiProperty({ required: false })
  coverImage: string | null;

  @ApiProperty({ enum: ArticleStatus })
  status: ArticleStatus;

  @ApiProperty()
  viewCount: number;

  @ApiProperty()
  likeCount: number;

  @ApiProperty({ required: false })
  metaTitle: string | null;

  @ApiProperty({ required: false })
  metaDescription: string | null;

  @ApiProperty({ required: false })
  metaKeywords: string | null;

  @ApiProperty({ required: false })
  publishedAt: Date | null;

  @ApiProperty()
  allowComments: boolean;

  @ApiProperty()
  isPinned: boolean;

  @ApiProperty()
  isFeatured: boolean;

  @ApiProperty()
  authorId: string;

  @ApiProperty()
  categoryId: string;

  @ApiProperty()
  createdAt: Date;

  @ApiProperty()
  updatedAt: Date;

  // ÂÖ≥ËÅîÊï∞ÊçÆÔºàÂèØÈÄâÔºâ
  @ApiProperty({ type: () => UserEntity, required: false })
  author?: UserEntity;

  @ApiProperty({ required: false })
  category?: any;

  @ApiProperty({ required: false })
  tags?: any[];

  @ApiProperty({ required: false })
  comments?: any[];

  constructor(article: Article & { author?: any; category?: any; tags?: any[]; comments?: any[] }) {
    Object.assign(this, article);
  }
}
```

## üîß ÂÆûÁé∞ÊñáÁ´†ÊúçÂä°

```typescript
// src/modules/articles/articles.service.ts
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';
import { QueryArticleDto } from './dto/query-article.dto';
import { ArticleEntity } from './entities/article.entity';
import { Article, ArticleStatus, Prisma, UserRole } from '@prisma/client';
import { UserEntity } from '../users/entities/user.entity';

@Injectable()
export class ArticlesService {
  constructor(private prisma: PrismaService) {}

  async create(
    createArticleDto: CreateArticleDto,
    authorId: string,
  ): Promise<ArticleEntity> {
    const { tagIds, ...articleData } = createArticleDto;

    // ÁîüÊàê slug
    const slug = await this.generateUniqueSlug(createArticleDto.title);

    // È™åËØÅÂàÜÁ±ªÊòØÂê¶Â≠òÂú®
    const category = await this.prisma.category.findUnique({
      where: { id: createArticleDto.categoryId },
    });

    if (!category) {
      throw new BadRequestException('ÊåáÂÆöÁöÑÂàÜÁ±ª‰∏çÂ≠òÂú®');
    }

    // È™åËØÅÊ†áÁ≠æÊòØÂê¶Â≠òÂú®
    if (tagIds && tagIds.length > 0) {
      const existingTags = await this.prisma.tag.findMany({
        where: { id: { in: tagIds } },
      });

      if (existingTags.length !== tagIds.length) {
        throw new BadRequestException('ÈÉ®ÂàÜÊ†áÁ≠æ‰∏çÂ≠òÂú®');
      }
    }

    try {
      const article = await this.prisma.article.create({
        data: {
          ...articleData,
          slug,
          authorId,
          publishedAt: articleData.status === ArticleStatus.PUBLISHED ? new Date() : null,
          // ÂàõÂª∫ÊñáÁ´†Ê†áÁ≠æÂÖ≥ËÅî
          articleTags: tagIds
            ? {
                create: tagIds.map((tagId) => ({
                  tag: { connect: { id: tagId } },
                })),
              }
            : undefined,
        },
        include: {
          author: true,
          category: true,
          articleTags: {
            include: {
              tag: true,
            },
          },
        },
      });

      // Êõ¥Êñ∞Ê†áÁ≠æ‰ΩøÁî®Ê¨°Êï∞
      if (tagIds && tagIds.length > 0) {
        await this.prisma.tag.updateMany({
          where: { id: { in: tagIds } },
          data: { useCount: { increment: 1 } },
        });
      }

      return new ArticleEntity({
        ...article,
        tags: article.articleTags.map((at) => at.tag),
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new BadRequestException('ÊñáÁ´†Ê†áÈ¢òÂ∑≤Â≠òÂú®');
        }
      }
      throw error;
    }
  }

  async findAll(queryDto: QueryArticleDto) {
    const {
      page = 1,
      limit = 10,
      search,
      status,
      categoryId,
      tagId,
      authorId,
      isPinned,
      isFeatured,
      sortBy = 'createdAt',
      sortOrder = 'desc',
    } = queryDto;

    const skip = (page - 1) * limit;

    // ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
    const where: Prisma.ArticleWhereInput = {};

    if (search) {
      where.OR = [
        { title: { contains: search } },
        { content: { contains: search } },
        { excerpt: { contains: search } },
      ];
    }

    if (status) {
      where.status = status;
    }

    if (categoryId) {
      where.categoryId = categoryId;
    }

    if (tagId) {
      where.articleTags = {
        some: {
          tagId: tagId,
        },
      };
    }

    if (authorId) {
      where.authorId = authorId;
    }

    if (isPinned !== undefined) {
      where.isPinned = isPinned;
    }

    if (isFeatured !== undefined) {
      where.isFeatured = isFeatured;
    }

    // ÊûÑÂª∫ÊéíÂ∫èÊù°‰ª∂
    const orderBy: Prisma.ArticleOrderByWithRelationInput = {};
    orderBy[sortBy] = sortOrder;

    const [articles, total] = await Promise.all([
      this.prisma.article.findMany({
        where,
        skip,
        take: limit,
        orderBy,
        include: {
          author: true,
          category: true,
          articleTags: {
            include: {
              tag: true,
            },
          },
          _count: {
            select: {
              comments: true,
            },
          },
        },
      }),
      this.prisma.article.count({ where }),
    ]);

    return {
      data: articles.map(
        (article) =>
          new ArticleEntity({
            ...article,
            tags: article.articleTags.map((at) => at.tag),
            commentsCount: article._count.comments,
          }),
      ),
      meta: {
        total,
        page,
        limit,
        totalPages: Math.ceil(total / limit),
        hasNextPage: page < Math.ceil(total / limit),
        hasPrevPage: page > 1,
      },
    };
  }

  async findBySlug(slug: string): Promise<ArticleEntity | null> {
    const article = await this.prisma.article.findUnique({
      where: { slug },
      include: {
        author: true,
        category: true,
        articleTags: {
          include: {
            tag: true,
          },
        },
        comments: {
          where: { status: 'APPROVED' },
          include: {
            author: true,
            replies: {
              include: {
                author: true,
              },
            },
          },
          orderBy: { createdAt: 'desc' },
        },
      },
    });

    if (!article) {
      return null;
    }

    // Â¢ûÂä†ÊµèËßàÊ¨°Êï∞
    await this.prisma.article.update({
      where: { id: article.id },
      data: { viewCount: { increment: 1 } },
    });

    return new ArticleEntity({
      ...article,
      tags: article.articleTags.map((at) => at.tag),
    });
  }

  async findById(id: string): Promise<ArticleEntity | null> {
    const article = await this.prisma.article.findUnique({
      where: { id },
      include: {
        author: true,
        category: true,
        articleTags: {
          include: {
            tag: true,
          },
        },
      },
    });

    return article
      ? new ArticleEntity({
          ...article,
          tags: article.articleTags.map((at) => at.tag),
        })
      : null;
  }

  async update(
    id: string,
    updateArticleDto: UpdateArticleDto,
    currentUser: UserEntity,
  ): Promise<ArticleEntity> {
    const article = await this.findById(id);
    if (!article) {
      throw new NotFoundException('ÊñáÁ´†‰∏çÂ≠òÂú®');
    }

    // ÊùÉÈôêÊ£ÄÊü•ÔºöÂè™Êúâ‰ΩúËÄÖÊàñÁÆ°ÁêÜÂëòÂèØ‰ª•ÁºñËæë
    if (
      article.authorId !== currentUser.id &&
      !['ADMIN', 'MODERATOR'].includes(currentUser.role)
    ) {
      throw new ForbiddenException('Êó†ÊùÉÁºñËæëÊ≠§ÊñáÁ´†');
    }

    const { tagIds, ...articleData } = updateArticleDto;

    // Â¶ÇÊûúÁä∂ÊÄÅÊîπ‰∏∫Â∑≤ÂèëÂ∏É‰∏î‰πãÂâçÊú™ÂèëÂ∏ÉÔºåËÆæÁΩÆÂèëÂ∏ÉÊó∂Èó¥
    if (
      articleData.status === ArticleStatus.PUBLISHED &&
      article.status !== ArticleStatus.PUBLISHED
    ) {
      articleData.publishedAt = new Date();
    }

    try {
      // Êõ¥Êñ∞ÊñáÁ´†Ê†áÁ≠æÂÖ≥ËÅî
      if (tagIds !== undefined) {
        // Âà†Èô§Áé∞ÊúâÊ†áÁ≠æÂÖ≥ËÅî
        await this.prisma.articleTag.deleteMany({
          where: { articleId: id },
        });

        // ÂàõÂª∫Êñ∞ÁöÑÊ†áÁ≠æÂÖ≥ËÅî
        if (tagIds.length > 0) {
          await this.prisma.articleTag.createMany({
            data: tagIds.map((tagId) => ({
              articleId: id,
              tagId,
            })),
          });

          // Êõ¥Êñ∞Ê†áÁ≠æ‰ΩøÁî®Ê¨°Êï∞
          await this.prisma.tag.updateMany({
            where: { id: { in: tagIds } },
            data: { useCount: { increment: 1 } },
          });
        }
      }

      const updatedArticle = await this.prisma.article.update({
        where: { id },
        data: articleData,
        include: {
          author: true,
          category: true,
          articleTags: {
            include: {
              tag: true,
            },
          },
        },
      });

      return new ArticleEntity({
        ...updatedArticle,
        tags: updatedArticle.articleTags.map((at) => at.tag),
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new BadRequestException('ÊñáÁ´†Ê†áÈ¢òÂ∑≤Â≠òÂú®');
        }
      }
      throw error;
    }
  }

  async remove(id: string, currentUser: UserEntity): Promise<void> {
    const article = await this.findById(id);
    if (!article) {
      throw new NotFoundException('ÊñáÁ´†‰∏çÂ≠òÂú®');
    }

    // ÊùÉÈôêÊ£ÄÊü•ÔºöÂè™Êúâ‰ΩúËÄÖÊàñÁÆ°ÁêÜÂëòÂèØ‰ª•Âà†Èô§
    if (
      article.authorId !== currentUser.id &&
      currentUser.role !== UserRole.ADMIN
    ) {
      throw new ForbiddenException('Êó†ÊùÉÂà†Èô§Ê≠§ÊñáÁ´†');
    }

    await this.prisma.article.delete({
      where: { id },
    });
  }

  async toggleLike(id: string): Promise<{ liked: boolean; likeCount: number }> {
    const article = await this.prisma.article.findUnique({
      where: { id },
    });

    if (!article) {
      throw new NotFoundException('ÊñáÁ´†‰∏çÂ≠òÂú®');
    }

    // ÁÆÄÂçïÁöÑÁÇπËµûÂÆûÁé∞ÔºàÂÆûÈôÖÈ°πÁõÆ‰∏≠Â∫îËØ•ËÆ∞ÂΩïÁî®Êà∑ÁÇπËµûÁä∂ÊÄÅÔºâ
    const updatedArticle = await this.prisma.article.update({
      where: { id },
      data: {
        likeCount: { increment: 1 },
      },
    });

    return {
      liked: true,
      likeCount: updatedArticle.likeCount,
    };
  }

  private async generateUniqueSlug(title: string): Promise<string> {
    let baseSlug = title
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-')
      .replace(/^-+|-+$/g, '');

    let slug = baseSlug;
    let counter = 1;

    while (await this.prisma.article.findUnique({ where: { slug } })) {
      slug = `${baseSlug}-${counter}`;
      counter++;
    }

    return slug;
  }

  async getArticleStats(authorId?: string) {
    const where: Prisma.ArticleWhereInput = authorId ? { authorId } : {};

    const [total, published, draft, archived] = await Promise.all([
      this.prisma.article.count({ where }),
      this.prisma.article.count({
        where: { ...where, status: ArticleStatus.PUBLISHED },
      }),
      this.prisma.article.count({
        where: { ...where, status: ArticleStatus.DRAFT },
      }),
      this.prisma.article.count({
        where: { ...where, status: ArticleStatus.ARCHIVED },
      }),
    ]);

    return {
      total,
      published,
      draft,
      archived,
    };
  }
}
```

## üéÆ ÂÆûÁé∞ÊñáÁ´†ÊéßÂà∂Âô®

```typescript
// src/modules/articles/articles.controller.ts
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  Query,
  UseGuards,
  ParseUUIDPipe,
  HttpCode,
  HttpStatus,
} from '@nestjs/common';
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBearerAuth,
  ApiParam,
} from '@nestjs/swagger';
import { ArticlesService } from './articles.service';
import { CreateArticleDto } from './dto/create-article.dto';
import { UpdateArticleDto } from './dto/update-article.dto';
import { QueryArticleDto } from './dto/query-article.dto';
import { ArticleEntity } from './entities/article.entity';
import { CurrentUser } from '../auth/decorators/current-user.decorator';
import { Roles } from '../auth/decorators/roles.decorator';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Public } from '../auth/decorators/public.decorator';
import { UserRole } from '@prisma/client';
import { UserEntity } from '../users/entities/user.entity';

@ApiTags('ÊñáÁ´†ÁÆ°ÁêÜ')
@Controller('articles')
@UseGuards(RolesGuard)
export class ArticlesController {
  constructor(private readonly articlesService: ArticlesService) {}

  @ApiBearerAuth()
  @Post()
  @ApiOperation({ summary: 'ÂàõÂª∫ÊñáÁ´†' })
  @ApiResponse({
    status: 201,
    description: 'ÊñáÁ´†ÂàõÂª∫ÊàêÂäü',
    type: ArticleEntity
  })
  async create(
    @Body() createArticleDto: CreateArticleDto,
    @CurrentUser('id') authorId: string,
  ): Promise<ArticleEntity> {
    return this.articlesService.create(createArticleDto, authorId);
  }

  @Public()
  @Get()
  @ApiOperation({ summary: 'Ëé∑ÂèñÊñáÁ´†ÂàóË°®' })
  @ApiResponse({
    status: 200,
    description: 'Ëé∑ÂèñÊàêÂäü',
    schema: {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: { $ref: '#/components/schemas/ArticleEntity' }
        },
        meta: {
          type: 'object',
          properties: {
            total: { type: 'number' },
            page: { type: 'number' },
            limit: { type: 'number' },
            totalPages: { type: 'number' },
            hasNextPage: { type: 'boolean' },
            hasPrevPage: { type: 'boolean' },
          }
        }
      }
    }
  })
  async findAll(@Query() queryDto: QueryArticleDto) {
    return this.articlesService.findAll(queryDto);
  }

  @Public()
  @Get('slug/:slug')
  @ApiOperation({ summary: 'Ê†πÊçÆ slug Ëé∑ÂèñÊñáÁ´†ËØ¶ÊÉÖ' })
  @ApiParam({ name: 'slug', description: 'ÊñáÁ´† slug' })
  @ApiResponse({
    status: 200,
    description: 'Ëé∑ÂèñÊàêÂäü',
    type: ArticleEntity
  })
  @ApiResponse({ status: 404, description: 'ÊñáÁ´†‰∏çÂ≠òÂú®' })
  async findBySlug(@Param('slug') slug: string): Promise<ArticleEntity> {
    const article = await this.articlesService.findBySlug(slug);
    if (!article) {
      throw new NotFoundException('ÊñáÁ´†‰∏çÂ≠òÂú®');
    }
    return article;
  }

  @Public()
  @Get('stats')
  @ApiOperation({ summary: 'Ëé∑ÂèñÊñáÁ´†ÁªüËÆ°‰ø°ÊÅØ' })
  @ApiResponse({ status: 200, description: 'Ëé∑ÂèñÊàêÂäü' })
  async getStats(@Query('authorId') authorId?: string) {
    return this.articlesService.getArticleStats(authorId);
  }

  @ApiBearerAuth()
  @Get('my')
  @ApiOperation({ summary: 'Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ÁöÑÊñáÁ´†ÂàóË°®' })
  @ApiResponse({ status: 200, description: 'Ëé∑ÂèñÊàêÂäü' })
  async getMyArticles(
    @CurrentUser('id') authorId: string,
    @Query() queryDto: QueryArticleDto,
  ) {
    return this.articlesService.findAll({ ...queryDto, authorId });
  }

  @Public()
  @Get(':id')
  @ApiOperation({ summary: 'Ê†πÊçÆIDËé∑ÂèñÊñáÁ´†ËØ¶ÊÉÖ' })
  @ApiParam({ name: 'id', description: 'ÊñáÁ´†ID', format: 'uuid' })
  @ApiResponse({
    status: 200,
    description: 'Ëé∑ÂèñÊàêÂäü',
    type: ArticleEntity
  })
  @ApiResponse({ status: 404, description: 'ÊñáÁ´†‰∏çÂ≠òÂú®' })
  async findOne(@Param('id', ParseUUIDPipe) id: string): Promise<ArticleEntity> {
    const article = await this.articlesService.findById(id);
    if (!article) {
      throw new NotFoundException('ÊñáÁ´†‰∏çÂ≠òÂú®');
    }
    return article;
  }

  @ApiBearerAuth()
  @Patch(':id')
  @ApiOperation({ summary: 'Êõ¥Êñ∞ÊñáÁ´†' })
  @ApiParam({ name: 'id', description: 'ÊñáÁ´†ID', format: 'uuid' })
  @ApiResponse({
    status: 200,
    description: 'Êõ¥Êñ∞ÊàêÂäü',
    type: ArticleEntity
  })
  @ApiResponse({ status: 404, description: 'ÊñáÁ´†‰∏çÂ≠òÂú®' })
  @ApiResponse({ status: 403, description: 'Êó†ÊùÉÁºñËæëÊ≠§ÊñáÁ´†' })
  async update(
    @Param('id', ParseUUIDPipe) id: string,
    @Body() updateArticleDto: UpdateArticleDto,
    @CurrentUser() currentUser: UserEntity,
  ): Promise<ArticleEntity> {
    return this.articlesService.update(id, updateArticleDto, currentUser);
  }

  @ApiBearerAuth()
  @Post(':id/like')
  @HttpCode(HttpStatus.OK)
  @ApiOperation({ summary: 'ÁÇπËµûÊñáÁ´†' })
  @ApiParam({ name: 'id', description: 'ÊñáÁ´†ID', format: 'uuid' })
  @ApiResponse({ status: 200, description: 'ÁÇπËµûÊàêÂäü' })
  @ApiResponse({ status: 404, description: 'ÊñáÁ´†‰∏çÂ≠òÂú®' })
  async toggleLike(@Param('id', ParseUUIDPipe) id: string) {
    return this.articlesService.toggleLike(id);
  }

  @ApiBearerAuth()
  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  @ApiOperation({ summary: 'Âà†Èô§ÊñáÁ´†' })
  @ApiParam({ name: 'id', description: 'ÊñáÁ´†ID', format: 'uuid' })
  @ApiResponse({ status: 204, description: 'Âà†Èô§ÊàêÂäü' })
  @ApiResponse({ status: 404, description: 'ÊñáÁ´†‰∏çÂ≠òÂú®' })
  @ApiResponse({ status: 403, description: 'Êó†ÊùÉÂà†Èô§Ê≠§ÊñáÁ´†' })
  async remove(
    @Param('id', ParseUUIDPipe) id: string,
    @CurrentUser() currentUser: UserEntity,
  ): Promise<void> {
    return this.articlesService.remove(id, currentUser);
  }
}
```

## üìÇ ÂÆûÁé∞ÂàÜÁ±ªÊ®°Âùó

### 1. ÂàÜÁ±ª DTO

```typescript
// src/modules/categories/dto/create-category.dto.ts
import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsInt,
  MaxLength,
  Matches,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateCategoryDto {
  @ApiProperty({
    description: 'ÂàÜÁ±ªÂêçÁß∞',
    example: 'ÊäÄÊúØ',
    maxLength: 100
  })
  @IsString({ message: 'ÂàÜÁ±ªÂêçÁß∞ÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @IsNotEmpty({ message: 'ÂàÜÁ±ªÂêçÁß∞‰∏çËÉΩ‰∏∫Á©∫' })
  @MaxLength(100, { message: 'ÂàÜÁ±ªÂêçÁß∞ÊúÄÂ§ö100‰∏™Â≠óÁ¨¶' })
  name: string;

  @ApiPropertyOptional({
    description: 'ÂàÜÁ±ªÊèèËø∞',
    maxLength: 500
  })
  @IsOptional()
  @IsString({ message: 'ÂàÜÁ±ªÊèèËø∞ÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(500, { message: 'ÂàÜÁ±ªÊèèËø∞ÊúÄÂ§ö500‰∏™Â≠óÁ¨¶' })
  description?: string;

  @ApiPropertyOptional({
    description: 'ÂàÜÁ±ªÈ¢úËâ≤ÔºàÂçÅÂÖ≠ËøõÂà∂Ôºâ',
    example: '#3B82F6',
    pattern: '^#[0-9A-Fa-f]{6}$'
  })
  @IsOptional()
  @IsString({ message: 'ÂàÜÁ±ªÈ¢úËâ≤ÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @Matches(/^#[0-9A-Fa-f]{6}$/, { message: 'ÂàÜÁ±ªÈ¢úËâ≤ÂøÖÈ°ªÊòØÊúâÊïàÁöÑÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤ÂÄº' })
  color?: string;

  @ApiPropertyOptional({
    description: 'ÂàÜÁ±ªÂõæÊ†á',
    maxLength: 50
  })
  @IsOptional()
  @IsString({ message: 'ÂàÜÁ±ªÂõæÊ†áÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(50, { message: 'ÂàÜÁ±ªÂõæÊ†áÊúÄÂ§ö50‰∏™Â≠óÁ¨¶' })
  icon?: string;

  @ApiPropertyOptional({
    description: 'ÊéíÂ∫èÈ°∫Â∫è',
    default: 0
  })
  @IsOptional()
  @IsInt({ message: 'ÊéíÂ∫èÈ°∫Â∫èÂøÖÈ°ªÊòØÊï¥Êï∞' })
  sortOrder?: number;

  @ApiPropertyOptional({
    description: 'SEOÊ†áÈ¢ò',
    maxLength: 255
  })
  @IsOptional()
  @IsString({ message: 'SEOÊ†áÈ¢òÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(255, { message: 'SEOÊ†áÈ¢òÊúÄÂ§ö255‰∏™Â≠óÁ¨¶' })
  metaTitle?: string;

  @ApiPropertyOptional({
    description: 'SEOÊèèËø∞',
    maxLength: 500
  })
  @IsOptional()
  @IsString({ message: 'SEOÊèèËø∞ÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @MaxLength(500, { message: 'SEOÊèèËø∞ÊúÄÂ§ö500‰∏™Â≠óÁ¨¶' })
  metaDescription?: string;
}
```

```typescript
// src/modules/categories/dto/update-category.dto.ts
import { PartialType } from '@nestjs/swagger';
import { CreateCategoryDto } from './create-category.dto';

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {}
```

### 2. ÂàÜÁ±ªÊúçÂä°

```typescript
// src/modules/categories/categories.service.ts
import {
  Injectable,
  NotFoundException,
  ConflictException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateCategoryDto } from './dto/create-category.dto';
import { UpdateCategoryDto } from './dto/update-category.dto';
import { Category, Prisma } from '@prisma/client';

@Injectable()
export class CategoriesService {
  constructor(private prisma: PrismaService) {}

  async create(createCategoryDto: CreateCategoryDto): Promise<Category> {
    const { name, ...rest } = createCategoryDto;

    // ÁîüÊàê slug
    const slug = this.generateSlug(name);

    // Ê£ÄÊü•ÂêçÁß∞Âíå slug ÊòØÂê¶Â∑≤Â≠òÂú®
    const existingCategory = await this.prisma.category.findFirst({
      where: {
        OR: [{ name }, { slug }],
      },
    });

    if (existingCategory) {
      throw new ConflictException('ÂàÜÁ±ªÂêçÁß∞Â∑≤Â≠òÂú®');
    }

    try {
      return await this.prisma.category.create({
        data: {
          name,
          slug,
          ...rest,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException('ÂàÜÁ±ªÂêçÁß∞Â∑≤Â≠òÂú®');
        }
      }
      throw error;
    }
  }

  async findAll(): Promise<Category[]> {
    return this.prisma.category.findMany({
      orderBy: [{ sortOrder: 'asc' }, { createdAt: 'asc' }],
      include: {
        _count: {
          select: {
            articles: {
              where: { status: 'PUBLISHED' },
            },
          },
        },
      },
    });
  }

  async findById(id: string): Promise<Category | null> {
    return this.prisma.category.findUnique({
      where: { id },
      include: {
        _count: {
          select: {
            articles: {
              where: { status: 'PUBLISHED' },
            },
          },
        },
      },
    });
  }

  async findBySlug(slug: string): Promise<Category | null> {
    return this.prisma.category.findUnique({
      where: { slug },
      include: {
        _count: {
          select: {
            articles: {
              where: { status: 'PUBLISHED' },
            },
          },
        },
      },
    });
  }

  async update(id: string, updateCategoryDto: UpdateCategoryDto): Promise<Category> {
    const category = await this.prisma.category.findUnique({
      where: { id },
    });

    if (!category) {
      throw new NotFoundException('ÂàÜÁ±ª‰∏çÂ≠òÂú®');
    }

    // Â¶ÇÊûúÊõ¥Êñ∞ÂêçÁß∞ÔºåÈúÄË¶ÅÈáçÊñ∞ÁîüÊàê slug
    let slug = category.slug;
    if (updateCategoryDto.name && updateCategoryDto.name !== category.name) {
      slug = this.generateSlug(updateCategoryDto.name);

      // Ê£ÄÊü•Êñ∞ÁöÑÂêçÁß∞Âíå slug ÊòØÂê¶Â∑≤Â≠òÂú®
      const existingCategory = await this.prisma.category.findFirst({
        where: {
          OR: [{ name: updateCategoryDto.name }, { slug }],
          NOT: { id },
        },
      });

      if (existingCategory) {
        throw new ConflictException('ÂàÜÁ±ªÂêçÁß∞Â∑≤Â≠òÂú®');
      }
    }

    try {
      return await this.prisma.category.update({
        where: { id },
        data: {
          ...updateCategoryDto,
          slug,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException('ÂàÜÁ±ªÂêçÁß∞Â∑≤Â≠òÂú®');
        }
      }
      throw error;
    }
  }

  async remove(id: string): Promise<void> {
    const category = await this.prisma.category.findUnique({
      where: { id },
      include: {
        _count: {
          select: { articles: true },
        },
      },
    });

    if (!category) {
      throw new NotFoundException('ÂàÜÁ±ª‰∏çÂ≠òÂú®');
    }

    if (category._count.articles > 0) {
      throw new BadRequestException('ËØ•ÂàÜÁ±ª‰∏ãËøòÊúâÊñáÁ´†ÔºåÊó†Ê≥ïÂà†Èô§');
    }

    await this.prisma.category.delete({
      where: { id },
    });
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}
```

## üè∑Ô∏è ÂÆûÁé∞Ê†áÁ≠æÊ®°Âùó

### 1. Ê†áÁ≠æÊúçÂä°ÔºàÁÆÄÂåñÁâàÔºâ

```typescript
// src/modules/tags/tags.service.ts
import {
  Injectable,
  NotFoundException,
  ConflictException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { Tag, Prisma } from '@prisma/client';

export interface CreateTagDto {
  name: string;
  description?: string;
  color?: string;
}

export interface UpdateTagDto {
  name?: string;
  description?: string;
  color?: string;
}

@Injectable()
export class TagsService {
  constructor(private prisma: PrismaService) {}

  async create(createTagDto: CreateTagDto): Promise<Tag> {
    const { name, ...rest } = createTagDto;
    const slug = this.generateSlug(name);

    try {
      return await this.prisma.tag.create({
        data: {
          name,
          slug,
          ...rest,
        },
      });
    } catch (error) {
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        if (error.code === 'P2002') {
          throw new ConflictException('Ê†áÁ≠æÂêçÁß∞Â∑≤Â≠òÂú®');
        }
      }
      throw error;
    }
  }

  async findAll(): Promise<Tag[]> {
    return this.prisma.tag.findMany({
      orderBy: [{ useCount: 'desc' }, { createdAt: 'desc' }],
      include: {
        _count: {
          select: { articleTags: true },
        },
      },
    });
  }

  async findById(id: string): Promise<Tag | null> {
    return this.prisma.tag.findUnique({
      where: { id },
    });
  }

  async update(id: string, updateTagDto: UpdateTagDto): Promise<Tag> {
    const tag = await this.findById(id);
    if (!tag) {
      throw new NotFoundException('Ê†áÁ≠æ‰∏çÂ≠òÂú®');
    }

    let slug = tag.slug;
    if (updateTagDto.name && updateTagDto.name !== tag.name) {
      slug = this.generateSlug(updateTagDto.name);
    }

    return this.prisma.tag.update({
      where: { id },
      data: {
        ...updateTagDto,
        slug,
      },
    });
  }

  async remove(id: string): Promise<void> {
    const tag = await this.findById(id);
    if (!tag) {
      throw new NotFoundException('Ê†áÁ≠æ‰∏çÂ≠òÂú®');
    }

    await this.prisma.tag.delete({
      where: { id },
    });
  }

  private generateSlug(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-')
      .replace(/^-+|-+$/g, '');
  }
}
```

## üí¨ ÂÆûÁé∞ËØÑËÆ∫Á≥ªÁªü

### 1. ËØÑËÆ∫ DTO

```typescript
// src/modules/comments/dto/create-comment.dto.ts
import {
  IsString,
  IsNotEmpty,
  IsOptional,
  IsUUID,
  MaxLength,
} from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';

export class CreateCommentDto {
  @ApiProperty({
    description: 'ËØÑËÆ∫ÂÜÖÂÆπ',
    example: 'ËøôÁØáÊñáÁ´†ÂÜôÂæóÂæàÂ•ΩÔºÅ',
    maxLength: 1000
  })
  @IsString({ message: 'ËØÑËÆ∫ÂÜÖÂÆπÂøÖÈ°ªÊòØÂ≠óÁ¨¶‰∏≤' })
  @IsNotEmpty({ message: 'ËØÑËÆ∫ÂÜÖÂÆπ‰∏çËÉΩ‰∏∫Á©∫' })
  @MaxLength(1000, { message: 'ËØÑËÆ∫ÂÜÖÂÆπÊúÄÂ§ö1000‰∏™Â≠óÁ¨¶' })
  content: string;

  @ApiProperty({
    description: 'ÊñáÁ´†ID',
    format: 'uuid'
  })
  @IsUUID(4, { message: 'ÊñáÁ´†IDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  @IsNotEmpty({ message: 'ÊñáÁ´†ID‰∏çËÉΩ‰∏∫Á©∫' })
  articleId: string;

  @ApiPropertyOptional({
    description: 'Áà∂ËØÑËÆ∫IDÔºàÂõûÂ§çËØÑËÆ∫Êó∂‰ΩøÁî®Ôºâ',
    format: 'uuid'
  })
  @IsOptional()
  @IsUUID(4, { message: 'Áà∂ËØÑËÆ∫IDÂøÖÈ°ªÊòØÊúâÊïàÁöÑUUID' })
  parentId?: string;
}
```

### 2. ËØÑËÆ∫ÊúçÂä°

```typescript
// src/modules/comments/comments.service.ts
import {
  Injectable,
  NotFoundException,
  ForbiddenException,
  BadRequestException,
} from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { CreateCommentDto } from './dto/create-comment.dto';
import { Comment, CommentStatus, UserRole } from '@prisma/client';
import { UserEntity } from '../users/entities/user.entity';

@Injectable()
export class CommentsService {
  constructor(private prisma: PrismaService) {}

  async create(
    createCommentDto: CreateCommentDto,
    authorId: string,
    ipAddress?: string,
    userAgent?: string,
  ): Promise<Comment> {
    const { articleId, parentId, content } = createCommentDto;

    // È™åËØÅÊñáÁ´†ÊòØÂê¶Â≠òÂú®‰∏îÂÖÅËÆ∏ËØÑËÆ∫
    const article = await this.prisma.article.findUnique({
      where: { id: articleId },
    });

    if (!article) {
      throw new NotFoundException('ÊñáÁ´†‰∏çÂ≠òÂú®');
    }

    if (!article.allowComments) {
      throw new BadRequestException('ËØ•ÊñáÁ´†‰∏çÂÖÅËÆ∏ËØÑËÆ∫');
    }

    // Â¶ÇÊûúÊòØÂõûÂ§çËØÑËÆ∫ÔºåÈ™åËØÅÁà∂ËØÑËÆ∫ÊòØÂê¶Â≠òÂú®
    if (parentId) {
      const parentComment = await this.prisma.comment.findUnique({
        where: { id: parentId },
      });

      if (!parentComment) {
        throw new NotFoundException('Áà∂ËØÑËÆ∫‰∏çÂ≠òÂú®');
      }

      if (parentComment.articleId !== articleId) {
        throw new BadRequestException('Áà∂ËØÑËÆ∫‰∏çÂ±û‰∫éËØ•ÊñáÁ´†');
      }
    }

    return this.prisma.comment.create({
      data: {
        content,
        articleId,
        authorId,
        parentId,
        ipAddress,
        userAgent,
        status: CommentStatus.PENDING, // ÈªòËÆ§ÂæÖÂÆ°Ê†∏
      },
      include: {
        author: true,
        replies: {
          include: {
            author: true,
          },
        },
      },
    });
  }

  async findByArticle(articleId: string) {
    return this.prisma.comment.findMany({
      where: {
        articleId,
        status: CommentStatus.APPROVED,
        parentId: null, // Âè™Ëé∑ÂèñÈ°∂Á∫ßËØÑËÆ∫
      },
      include: {
        author: true,
        replies: {
          where: { status: CommentStatus.APPROVED },
          include: {
            author: true,
          },
          orderBy: { createdAt: 'asc' },
        },
      },
      orderBy: { createdAt: 'desc' },
    });
  }

  async updateStatus(
    id: string,
    status: CommentStatus,
    currentUser: UserEntity,
  ): Promise<Comment> {
    // Âè™ÊúâÁÆ°ÁêÜÂëòÂíåÁâà‰∏ªÂèØ‰ª•Êõ¥Êñ∞ËØÑËÆ∫Áä∂ÊÄÅ
    if (!['ADMIN', 'MODERATOR'].includes(currentUser.role)) {
      throw new ForbiddenException('Êó†ÊùÉÊõ¥Êñ∞ËØÑËÆ∫Áä∂ÊÄÅ');
    }

    const comment = await this.prisma.comment.findUnique({
      where: { id },
    });

    if (!comment) {
      throw new NotFoundException('ËØÑËÆ∫‰∏çÂ≠òÂú®');
    }

    return this.prisma.comment.update({
      where: { id },
      data: { status },
    });
  }

  async remove(id: string, currentUser: UserEntity): Promise<void> {
    const comment = await this.prisma.comment.findUnique({
      where: { id },
    });

    if (!comment) {
      throw new NotFoundException('ËØÑËÆ∫‰∏çÂ≠òÂú®');
    }

    // Âè™ÊúâËØÑËÆ∫‰ΩúËÄÖÊàñÁÆ°ÁêÜÂëòÂèØ‰ª•Âà†Èô§ËØÑËÆ∫
    if (
      comment.authorId !== currentUser.id &&
      currentUser.role !== UserRole.ADMIN
    ) {
      throw new ForbiddenException('Êó†ÊùÉÂà†Èô§Ê≠§ËØÑËÆ∫');
    }

    await this.prisma.comment.delete({
      where: { id },
    });
  }
}
```

## üîß ÈÖçÁΩÆÊ®°Âùó

### 1. ÊñáÁ´†Ê®°Âùó

```typescript
// src/modules/articles/articles.module.ts
import { Module } from '@nestjs/common';
import { ArticlesService } from './articles.service';
import { ArticlesController } from './articles.controller';

@Module({
  controllers: [ArticlesController],
  providers: [ArticlesService],
  exports: [ArticlesService],
})
export class ArticlesModule {}
```

### 2. ÂàÜÁ±ªÊ®°Âùó

```typescript
// src/modules/categories/categories.module.ts
import { Module } from '@nestjs/common';
import { CategoriesService } from './categories.service';
import { CategoriesController } from './categories.controller';

@Module({
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService],
})
export class CategoriesModule {}
```

### 3. Êõ¥Êñ∞‰∏ªÊ®°Âùó

```typescript
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { APP_GUARD } from '@nestjs/core';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { PrismaModule } from './prisma/prisma.module';
import { UsersModule } from './modules/users/users.module';
import { AuthModule } from './modules/auth/auth.module';
import { ArticlesModule } from './modules/articles/articles.module';
import { CategoriesModule } from './modules/categories/categories.module';
import { TagsModule } from './modules/tags/tags.module';
import { CommentsModule } from './modules/comments/comments.module';
import { JwtAuthGuard } from './modules/auth/guards/jwt-auth.guard';
import configuration from './config/configuration';

@Module({
  imports: [
    ConfigModule.forRoot({
      load: [configuration],
      isGlobal: true,
      envFilePath: '.env',
    }),
    PrismaModule,
    UsersModule,
    AuthModule,
    ArticlesModule,
    CategoriesModule,
    TagsModule,
    CommentsModule,
  ],
  controllers: [AppController],
  providers: [
    AppService,
    {
      provide: APP_GUARD,
      useClass: JwtAuthGuard,
    },
  ],
})
export class AppModule {}
```

## ‚úÖ ÊµãËØïÊñáÁ´†ÁÆ°ÁêÜÂäüËÉΩ

### 1. ÂàõÂª∫ÂàÜÁ±ª

```bash
curl -X POST http://localhost:3000/categories \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_ADMIN_TOKEN" \
  -d '{
    "name": "ÊäÄÊúØ",
    "description": "ÊäÄÊúØÁõ∏ÂÖ≥ÊñáÁ´†",
    "color": "#3B82F6"
  }'
```

### 2. ÂàõÂª∫Ê†áÁ≠æ

```bash
curl -X POST http://localhost:3000/tags \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "name": "NestJS",
    "description": "NestJSÊ°ÜÊû∂Áõ∏ÂÖ≥",
    "color": "#E11D48"
  }'
```

### 3. ÂàõÂª∫ÊñáÁ´†

```bash
curl -X POST http://localhost:3000/articles \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "title": "NestJS ÂÆûÊàòÊåáÂçó",
    "content": "ËøôÊòØ‰∏ÄÁØáÂÖ≥‰∫é NestJS ÁöÑËØ¶ÁªÜÊïôÁ®ã...",
    "excerpt": "Â≠¶‰π†Â¶Ç‰Ωï‰ΩøÁî® NestJS ÊûÑÂª∫‰ºÅ‰∏öÁ∫ßÂ∫îÁî®",
    "categoryId": "CATEGORY_ID",
    "tagIds": ["TAG_ID_1", "TAG_ID_2"],
    "status": "PUBLISHED"
  }'
```

### 4. Ëé∑ÂèñÊñáÁ´†ÂàóË°®

```bash
curl -X GET "http://localhost:3000/articles?page=1&limit=10&status=PUBLISHED"
```

### 5. Ê∑ªÂä†ËØÑËÆ∫

```bash
curl -X POST http://localhost:3000/comments \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{
    "content": "ËøôÁØáÊñáÁ´†ÂÜôÂæóÂæàÂ•ΩÔºÅ",
    "articleId": "ARTICLE_ID"
  }'
```

## üéâ Â∞èÁªì

Âú®Êú¨Á´†‰∏≠ÔºåÊàë‰ª¨ÂÆåÊàê‰∫ÜÔºö
- ‚úÖ ÂàõÂª∫‰∫ÜÂÆåÊï¥ÁöÑÊñáÁ´†ÁÆ°ÁêÜÁ≥ªÁªü
- ‚úÖ ÂÆûÁé∞‰∫ÜÊñáÁ´†ÁöÑ CRUD Êìç‰Ωú
- ‚úÖ ÂàõÂª∫‰∫ÜÂàÜÁ±ªÂíåÊ†áÁ≠æÁÆ°ÁêÜ
- ‚úÖ ÂÆûÁé∞‰∫ÜÊñáÁ´†ÊêúÁ¥¢ÂíåÂàÜÈ°µÂäüËÉΩ
- ‚úÖ ÂàõÂª∫‰∫ÜËØÑËÆ∫Á≥ªÁªü
- ‚úÖ ÂÆûÁé∞‰∫ÜÊùÉÈôêÊéßÂà∂ÂíåÁä∂ÊÄÅÁÆ°ÁêÜ

Âú®‰∏ã‰∏ÄÁ´†‰∏≠ÔºåÊàë‰ª¨Â∞ÜÂàõÂª∫ÂÖ¨ÂÖ±ÁªÑ‰ª∂‰∏éÂ∑•ÂÖ∑ÔºåÂåÖÊã¨Êã¶Êà™Âô®„ÄÅÁÆ°ÈÅì„ÄÅËøáÊª§Âô®Á≠âÈÄöÁî®ÁªÑ‰ª∂„ÄÇ
